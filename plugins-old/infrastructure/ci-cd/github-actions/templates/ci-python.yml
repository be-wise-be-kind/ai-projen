# Purpose: Python code quality and testing workflow using dedicated Docker linting containers
# Scope: Complete linting coverage for Python with Docker-first CI/CD pattern
# Overview: Executes comprehensive code quality checks using dedicated linting containers that separate
#     linting tools from development environments. Implements optimized Docker registry caching with
#     conditional rebuilds, reducing CI time by 80-90% when dependencies haven't changed. Uses GitHub
#     Container Registry (GHCR) to cache pre-built linting images and only rebuilds when Dockerfiles
#     or dependency files change. Runs multiple linting tools including Ruff, MyPy, Bandit, Pylint,
#     Flake8, and complexity analysis with Radon/Xenon in isolated containers.
# Dependencies: Docker BuildKit, GHCR registry cache, Python plugin make targets, docker-compose
# Exports: Linting execution status, test results, code quality reports, and comprehensive summaries
# Environment: GitHub Actions CI/CD pipeline with GHCR-based image caching for linting containers
# Related: .docker/dockerfiles/, docker-compose.yml, Makefile
# Implementation: Uses GHCR registry cache with conditional rebuilds based on file change detection

name: Python CI

on:
  pull_request:
    branches: [main, develop]
    paths:
      - '**/*.py'
      - 'pyproject.toml'
      - 'poetry.lock'
      - 'requirements*.txt'
      - '.github/workflows/ci-python.yml'
      - 'Dockerfile*'
      - 'docker-compose*.yml'
  push:
    branches: [main]
    paths:
      - '**/*.py'
      - 'pyproject.toml'
      - 'poetry.lock'
      - 'requirements*.txt'

env:
  PYTHON_VERSION: '3.11'  # Customize: Your Python version
  DOCKER_BUILDKIT: 1
  COMPOSE_DOCKER_CLI_BUILD: 1
  REGISTRY: ghcr.io
  IMAGE_PREFIX: ghcr.io/${{ github.repository_owner }}/{{PROJECT_NAME}}  # Customize: Replace {{PROJECT_NAME}}

jobs:
  lint-and-test:
    name: Python Linting & Testing
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 2  # Need previous commit to detect changes

      # Set up Docker Buildx for advanced caching features
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      # Login to GitHub Container Registry for caching
      - name: Login to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      # Detect if linting dependencies have changed
      - name: Check if linting dependencies changed
        id: lint-deps-check
        run: |
          # Files that affect linting container builds
          LINT_FILES=(
            "Dockerfile"
            "Dockerfile.python"
            ".docker/dockerfiles/Dockerfile.backend"
            "pyproject.toml"
            "poetry.lock"
            "requirements.txt"
            "requirements-dev.txt"
          )

          # Check if any lint dependency files changed
          CHANGED=false
          for file in "${LINT_FILES[@]}"; do
            if [ -f "$file" ] && git diff --name-only HEAD~1 HEAD | grep -q "^${file}$"; then
              echo "Detected change in: $file"
              CHANGED=true
              break
            fi
          done

          # Always rebuild on main branch to refresh cache
          if [ "${{ github.ref }}" == "refs/heads/main" ]; then
            echo "On main branch - will rebuild and cache"
            CHANGED=true
          fi

          echo "rebuild_needed=$CHANGED" >> $GITHUB_OUTPUT

          if [ "$CHANGED" == "true" ]; then
            echo "🔨 Linting container will be rebuilt"
          else
            echo "✨ Using cached linting container (no dependency changes detected)"
          fi

      # Build or pull Python linting container
      - name: Build or pull Python linting container
        run: |
          PYTHON_IMAGE="${{ env.IMAGE_PREFIX }}-python-linter:latest"
          REBUILD="${{ steps.lint-deps-check.outputs.rebuild_needed }}"

          # Determine which Dockerfile to use (check common locations)
          if [ -f ".docker/dockerfiles/Dockerfile.backend" ]; then
            DOCKERFILE=".docker/dockerfiles/Dockerfile.backend"
          elif [ -f "Dockerfile.python" ]; then
            DOCKERFILE="Dockerfile.python"
          elif [ -f "Dockerfile" ]; then
            DOCKERFILE="Dockerfile"
          else
            echo "Error: No Dockerfile found for Python"
            exit 1
          fi

          if [ "$REBUILD" == "true" ]; then
            echo "Building Python linting container with registry cache..."
            docker buildx build \
              --cache-from type=registry,ref=${PYTHON_IMAGE} \
              --cache-to type=registry,ref=${PYTHON_IMAGE},mode=max \
              --target lint \
              --load \
              -t {{PROJECT_NAME}}-python-linter:latest \
              -f ${DOCKERFILE} \
              .
            echo "✓ Python linting container built and cached"
          else
            echo "Pulling cached Python linting container..."
            docker pull ${PYTHON_IMAGE} || echo "No cache found, will build"
            if docker image inspect ${PYTHON_IMAGE} >/dev/null 2>&1; then
              docker tag ${PYTHON_IMAGE} {{PROJECT_NAME}}-python-linter:latest
              echo "✓ Python linting container pulled from cache"
            else
              echo "Cache miss - building Python linting container..."
              docker buildx build \
                --cache-from type=registry,ref=${PYTHON_IMAGE} \
                --cache-to type=registry,ref=${PYTHON_IMAGE},mode=max \
                --target lint \
                --load \
                -t {{PROJECT_NAME}}-python-linter:latest \
                -f ${DOCKERFILE} \
                .
            fi
          fi

      # Run Python linting
      - name: Run Python linting
        run: |
          # Check if using Make or direct Docker commands
          if [ -f "Makefile" ] && grep -q "lint-python" Makefile; then
            echo "Running linting via Make..."
            make lint-python
          else
            echo "Running linting via Docker..."
            # Fallback to direct Docker commands if no Makefile
            docker run --rm -v $(pwd):/app {{PROJECT_NAME}}-python-linter:latest ruff check .
            docker run --rm -v $(pwd):/app {{PROJECT_NAME}}-python-linter:latest black --check .
            docker run --rm -v $(pwd):/app {{PROJECT_NAME}}-python-linter:latest mypy .
            docker run --rm -v $(pwd):/app {{PROJECT_NAME}}-python-linter:latest bandit -r . -ll
          fi

      # Build dev container for testing
      - name: Build Python dev container
        run: |
          # Determine Dockerfile
          if [ -f ".docker/dockerfiles/Dockerfile.backend" ]; then
            DOCKERFILE=".docker/dockerfiles/Dockerfile.backend"
          elif [ -f "Dockerfile.python" ]; then
            DOCKERFILE="Dockerfile.python"
          elif [ -f "Dockerfile" ]; then
            DOCKERFILE="Dockerfile"
          else
            echo "Error: No Dockerfile found for Python"
            exit 1
          fi

          echo "Building Python dev container..."
          docker buildx build \
            --cache-from type=gha \
            --cache-to type=gha,mode=max \
            --target dev \
            --load \
            -t {{PROJECT_NAME}}-python-dev:latest \
            -f ${DOCKERFILE} \
            .

      # Run Python tests
      - name: Run Python tests
        run: |
          # Check if using Make or direct Docker commands
          if [ -f "Makefile" ] && grep -q "test-python" Makefile; then
            echo "Running tests via Make..."
            make test-python
          else
            echo "Running tests via Docker..."
            docker run --rm -v $(pwd):/app {{PROJECT_NAME}}-python-dev:latest pytest --cov --cov-report=xml --cov-report=html
          fi

      # Upload coverage reports
      - name: Upload coverage reports
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: python-coverage
          path: |
            coverage.xml
            htmlcov/
          retention-days: 30

      # Generate summary
      - name: Generate Python CI summary
        if: always()
        run: |
          echo "## 🐍 Python CI Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### 🔍 Linting Tools Executed:" >> $GITHUB_STEP_SUMMARY
          echo "- **Ruff**: Fast Python linting" >> $GITHUB_STEP_SUMMARY
          echo "- **Black**: Code formatting validation" >> $GITHUB_STEP_SUMMARY
          echo "- **MyPy**: Static type checking" >> $GITHUB_STEP_SUMMARY
          echo "- **Bandit**: Security vulnerability scanning" >> $GITHUB_STEP_SUMMARY
          echo "- **Pylint**: Comprehensive code analysis (if configured)" >> $GITHUB_STEP_SUMMARY
          echo "- **Flake8**: Style guide enforcement (if configured)" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### 🧪 Testing:" >> $GITHUB_STEP_SUMMARY
          echo "- **pytest**: Unit and integration tests" >> $GITHUB_STEP_SUMMARY
          echo "- **Coverage**: Code coverage analysis" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### 🐳 Containers Used:" >> $GITHUB_STEP_SUMMARY
          echo "- **Linting Container**: \`{{PROJECT_NAME}}-python-linter\`" >> $GITHUB_STEP_SUMMARY
          echo "- **Dev Container**: \`{{PROJECT_NAME}}-python-dev\`" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### ⚡ Performance:" >> $GITHUB_STEP_SUMMARY
          if [ "${{ steps.lint-deps-check.outputs.rebuild_needed }}" == "false" ]; then
            echo "- ✨ **Cache Hit**: Linting container pulled from cache" >> $GITHUB_STEP_SUMMARY
            echo "- **Time Savings**: ~80-90% faster than rebuilding" >> $GITHUB_STEP_SUMMARY
          else
            echo "- 🔨 **Rebuild**: Dependencies changed, container rebuilt and cached" >> $GITHUB_STEP_SUMMARY
            echo "- **Cache Updated**: Future runs will be faster" >> $GITHUB_STEP_SUMMARY
          fi
