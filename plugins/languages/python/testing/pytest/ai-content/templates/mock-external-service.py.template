"""
Purpose: Template for mocking external services including HTTP APIs, databases, and file systems

Scope: Test mocking patterns, external dependency isolation, test doubles

Overview: Generates comprehensive test module demonstrating mocking patterns for external services
    and dependencies including HTTP requests (sync and async), database operations with SQLAlchemy,
    file system operations, datetime and time functions, environment variables, and complex
    side effects. Provides complete examples for isolating tests from external dependencies using
    unittest.mock and pytest-mock, including Mock, AsyncMock, MagicMock, patch decorator, and
    monkeypatch fixture. Covers mock assertions, side effect sequences, exception simulation,
    and retry logic testing. Essential patterns for writing fast, reliable, isolated unit tests.

Dependencies: Pytest (testing framework), pytest-mock (mocker fixture), unittest.mock (Mock,
    AsyncMock, patch), httpx for HTTP examples

Exports: Multiple test classes demonstrating mocking patterns - HTTP requests, database operations,
    file system, time/dates, environment variables, side effects, and mock assertions

Placeholders: None - this is a reference template with example implementations

Usage: Copy template to target location, replace all {{PLACEHOLDERS}}, customize implementation

Related: Unittest.mock documentation, pytest-mock plugin, testing best practices

Implementation: Uses mocker fixture from pytest-mock, Mock/AsyncMock for objects, patch for
    module-level mocking, monkeypatch for environment variables, side_effect for sequences
"""
import pytest
from unittest.mock import Mock, AsyncMock, MagicMock, patch
import httpx


class TestMockingHTTPRequests:
    """Mocking HTTP API calls."""

    def test_mock_httpx_get(self, mocker):
        """Mock synchronous HTTP GET request."""
        mock_response = Mock()
        mock_response.json.return_value = {"id": 1, "name": "Test"}
        mock_response.status_code = 200

        mocker.patch("httpx.get", return_value=mock_response)

        # Code being tested would call httpx.get()
        response = httpx.get("https://api.example.com/users/1")

        assert response.json() == {"id": 1, "name": "Test"}
        assert response.status_code == 200

    @pytest.mark.asyncio
    async def test_mock_async_http_call(self, mocker):
        """Mock async HTTP request."""
        mock_response = Mock()
        mock_response.json.return_value = {"data": "test"}
        mock_response.status_code = 200

        mock_get = mocker.patch("httpx.AsyncClient.get", return_value=mock_response)

        async with httpx.AsyncClient() as client:
            response = await client.get("https://api.example.com/data")

        assert response.json() == {"data": "test"}
        mock_get.assert_called_once()


class TestMockingDatabase:
    """Mocking database operations."""

    def test_mock_database_query(self, mocker):
        """Mock SQLAlchemy database query."""
        from sqlalchemy.orm import Session
        from app.models import User

        mock_session = mocker.Mock(spec=Session)
        mock_user = User(id=1, email="test@example.com", name="Test")

        # Mock the query chain
        mock_query = mocker.Mock()
        mock_query.filter_by.return_value.first.return_value = mock_user
        mock_session.query.return_value = mock_query

        # Code being tested
        from app.services import get_user_by_email

        result = get_user_by_email(mock_session, "test@example.com")

        assert result.id == 1
        mock_session.query.assert_called_once_with(User)

    def test_mock_database_add_commit(self, mocker):
        """Mock database add and commit operations."""
        from sqlalchemy.orm import Session

        mock_session = mocker.Mock(spec=Session)

        # Code that adds and commits
        from app.models import User
        user = User(email="new@example.com", name="New User")
        mock_session.add(user)
        mock_session.commit()

        mock_session.add.assert_called_once_with(user)
        mock_session.commit.assert_called_once()


class TestMockingFileSystem:
    """Mocking file system operations."""

    def test_mock_file_read(self, mocker):
        """Mock file reading."""
        import json

        mock_config = {"api_key": "test-key", "timeout": 30}
        mock_open = mocker.mock_open(read_data=json.dumps(mock_config))
        mocker.patch("builtins.open", mock_open)

        # Code being tested
        with open("/etc/config.json", "r") as f:
            config = json.load(f)

        assert config == mock_config
        mock_open.assert_called_once_with("/etc/config.json", "r")

    def test_mock_file_write(self, mocker):
        """Mock file writing."""
        mock_open = mocker.mock_open()
        mocker.patch("builtins.open", mock_open)

        # Code being tested
        with open("/tmp/output.txt", "w") as f:
            f.write("test data")

        mock_open.assert_called_once_with("/tmp/output.txt", "w")
        mock_open().write.assert_called_once_with("test data")


class TestMockingTimeAndDates:
    """Mocking datetime and time functions."""

    def test_mock_datetime_now(self, mocker):
        """Mock datetime.now() to fixed time."""
        from datetime import datetime

        fixed_time = datetime(2024, 1, 1, 12, 0, 0)
        mock_datetime = mocker.patch("app.services.datetime")
        mock_datetime.now.return_value = fixed_time

        # Code being tested
        from app.services import get_current_timestamp

        result = get_current_timestamp()

        assert result == fixed_time

    def test_mock_time_sleep(self, mocker):
        """Mock time.sleep to avoid waiting."""
        import time

        mock_sleep = mocker.patch("time.sleep")

        # Code that sleeps
        time.sleep(10)  # Doesn't actually sleep

        mock_sleep.assert_called_once_with(10)


class TestMockingEnvironmentVariables:
    """Mocking environment variables."""

    def test_mock_env_vars(self, monkeypatch):
        """Mock environment variables."""
        monkeypatch.setenv("API_KEY", "test-api-key-123")
        monkeypatch.setenv("DB_HOST", "test-db.example.com")

        import os
        assert os.getenv("API_KEY") == "test-api-key-123"
        assert os.getenv("DB_HOST") == "test-db.example.com"

    def test_clear_env_vars(self, monkeypatch):
        """Clear environment variables for testing."""
        monkeypatch.delenv("API_KEY", raising=False)

        import os
        assert os.getenv("API_KEY") is None


class TestMockingSideEffects:
    """Using side_effect for complex mocking."""

    def test_mock_side_effect_sequence(self, mocker):
        """Mock function returns different values on successive calls."""
        mock_func = mocker.Mock()
        mock_func.side_effect = [1, 2, 3]

        assert mock_func() == 1
        assert mock_func() == 2
        assert mock_func() == 3

    def test_mock_side_effect_exception(self, mocker):
        """Mock function raises exception."""
        mock_func = mocker.Mock()
        mock_func.side_effect = ValueError("Test error")

        with pytest.raises(ValueError, match="Test error"):
            mock_func()

    def test_mock_retry_with_side_effect(self, mocker):
        """Mock function fails twice then succeeds."""
        mock_operation = mocker.Mock()
        mock_operation.side_effect = [
            ConnectionError("First attempt fails"),
            ConnectionError("Second attempt fails"),
            "Success on third attempt"
        ]

        # Retry logic
        for attempt in range(3):
            try:
                result = mock_operation()
                break
            except ConnectionError:
                continue

        assert result == "Success on third attempt"
        assert mock_operation.call_count == 3


class TestMockAssertions:
    """Various mock assertion patterns."""

    def test_assert_called_once(self, mocker):
        """Verify mock was called exactly once."""
        mock_func = mocker.Mock()
        mock_func()

        mock_func.assert_called_once()

    def test_assert_called_with_args(self, mocker):
        """Verify mock was called with specific arguments."""
        mock_func = mocker.Mock()
        mock_func(42, "test", key="value")

        mock_func.assert_called_with(42, "test", key="value")

    def test_assert_not_called(self, mocker):
        """Verify mock was never called."""
        mock_func = mocker.Mock()

        mock_func.assert_not_called()

    def test_inspect_call_args(self, mocker):
        """Inspect arguments passed to mock."""
        mock_func = mocker.Mock()
        mock_func(123, name="test")

        args, kwargs = mock_func.call_args
        assert args == (123,)
        assert kwargs == {"name": "test"}
