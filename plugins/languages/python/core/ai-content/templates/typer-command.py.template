"""
Purpose: Template for Typer CLI command with Rich formatting, type annotations, and error handling

Scope: Modern command-line interface development, CLI tools with rich output, terminal applications

Overview: Generates Python module for Typer-based command-line interface with modern CLI patterns
    including annotated type hints for arguments and options, Rich library integration for
    beautiful terminal output with colors and formatting, progress indicators, comprehensive
    help text, and robust error handling. Provides structure for building production-ready CLI
    commands with proper type validation, user-friendly output, and professional error messages.
    Follows Typer best practices for creating intuitive and visually appealing command-line tools.

Dependencies: Typer (modern CLI framework), Rich (terminal formatting), typing for annotations,
    pathlib for path handling

Exports: Typer app instance with command configuration, command function with Rich console output

Placeholders:
    - {{COMMAND_NAME}}: Name of the CLI command (e.g., "deploy", "build")
    - {{PURPOSE}}: Brief purpose statement for the command
    - {{DESCRIPTION}}: Description of what the command does
    - {{FUNCTION_NAME}}: Python function name for command (e.g., "deploy_app", "build_project")
    - {{PARAMETER_NAME}}: Name of command parameter (e.g., "target", "source")
    - {{PARAMETER_TYPE}}: Python type for parameter (e.g., "str", "Path", "int")
    - {{PARAMETER_DESCRIPTION}}: Description of what parameter does
    - {{OPTION_DESCRIPTION}}: Description of what option controls
    - {{COMMAND_DESCRIPTION}}: Full description shown in help text
    - {{COMMAND_FULL_DESCRIPTION}}: Detailed description for docstring

Usage: Copy template to target location, replace all {{PLACEHOLDERS}}, customize implementation

Related: Typer documentation, Rich library formatting, CLI design patterns

Implementation: Uses Typer.Typer() app instance, Annotated type hints with Argument/Option,
    Rich Console for formatted output, proper error handling with Exit codes
"""

import typer
from rich.console import Console
from typing import Annotated, Optional
from pathlib import Path

console = Console()
app = typer.Typer(help="{{COMMAND_DESCRIPTION}}")


@app.command()
def {{FUNCTION_NAME}}(
    {{PARAMETER_NAME}}: Annotated[{{PARAMETER_TYPE}}, typer.Argument(help="{{PARAMETER_DESCRIPTION}}")],
    option: Annotated[str, typer.Option("--option", "-o", help="{{OPTION_DESCRIPTION}}")] = "default",
    verbose: Annotated[bool, typer.Option("--verbose", "-v", help="Enable verbose output")] = False,
) -> None:
    """{{COMMAND_FULL_DESCRIPTION}}.

    Args:
        {{PARAMETER_NAME}}: {{PARAMETER_DESCRIPTION}}
        option: {{OPTION_DESCRIPTION}}
        verbose: Enable verbose output

    Examples:
        {{COMMAND_NAME}} {{FUNCTION_NAME}} arg1 --option value
        {{COMMAND_NAME}} {{FUNCTION_NAME}} arg1 --verbose
    """
    if verbose:
        console.print(f"[dim]Running {{FUNCTION_NAME}} with {{{PARAMETER_NAME}}}[/dim]")

    try:
        # TODO: Implement command logic
        console.print(f"[green]Processing {{{PARAMETER_NAME}}}...[/green]")

        # Example: Process with progress
        # from rich.progress import track
        # for item in track(items, description="Processing..."):
        #     process(item)

        console.print("[bold green]✓ Complete![/bold green]")

    except Exception as e:
        console.print(f"[red]✗ Error: {e}[/red]")
        raise typer.Exit(code=1)


if __name__ == '__main__':
    app()
