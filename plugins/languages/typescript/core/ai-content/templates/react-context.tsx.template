/**
 * Purpose: Template for React Context - global state management with Context API
 *
 * Scope: Application-wide or feature-wide shared state management
 *
 * Overview: Generates a React Context provider with state management capabilities using
 *     the Context API pattern. Provides centralized state management for sharing data
 *     across component trees without prop drilling. Includes TypeScript interfaces for
 *     state shape and context value, provider component with state initialization,
 *     action methods for state updates, and custom hook for consuming context with
 *     error checking. The generated context follows React best practices with proper
 *     TypeScript typing, memoized action callbacks to prevent unnecessary re-renders,
 *     initial state support for testing and SSR, and runtime validation to ensure
 *     hook usage within provider. Suitable for managing authentication state, theme
 *     preferences, user settings, feature flags, and other application-wide state
 *     that multiple components need to access and modify.
 *
 * Dependencies: React 18+ with Context API and hooks
 *
 * Exports: Provider component, custom hook for consuming context, context interfaces
 *
 * Placeholders:
 *     - {{CONTEXT_PURPOSE}}: Context purpose (e.g., "User authentication state")
 *     - {{CONTEXT_SCOPE}}: Context scope (e.g., "Global authentication")
 *     - {{CONTEXT_NAME}}: Context name in PascalCase (e.g., "Auth", "Theme", "UserSettings")
 *     - {{CONTEXT_DESCRIPTION}}: Detailed context description
 *     - {{STATE_FIELD}}: First state field name (e.g., "user", "theme", "isAuthenticated")
 *     - {{STATE_TYPE}}: First state field TypeScript type (e.g., "User | null", "ThemeMode")
 *     - {{STATE_FIELD_2}}: Second state field name (e.g., "isLoading", "preferences")
 *     - {{STATE_TYPE_2}}: Second state field type (e.g., "boolean", "UserPreferences")
 *     - {{ACTION_NAME}}: First action function name (e.g., "login", "setTheme", "updateUser")
 *     - {{ACTION_PARAM}}: Action parameter name (e.g., "credentials", "theme", "userData")
 *     - {{ACTION_PARAM_TYPE}}: Action parameter type (e.g., "LoginCredentials", "ThemeMode")
 *     - {{ACTION_NAME_2}}: Second action name (e.g., "logout", "reset", "clearUser")
 *     - {{DEFAULT_VALUE}}: Default value for first state field (e.g., "null", "'light'")
 *     - {{DEFAULT_VALUE_2}}: Default value for second state field (e.g., "false", "{}")
 *     - {{ACTION_LOGIC}}: Logic for action implementation (e.g., "action.payload", "newValue")
 *
 * Usage: Copy template to context directory, replace all {{PLACEHOLDERS}}, add additional state fields and actions, wrap application or feature tree with Provider
 *
 * Related: react-component-with-hooks.tsx.template for consuming context in components, zustand-store.ts.template for alternative state management
 *
 * Implementation: Context API with TypeScript, custom hook with runtime validation, memoized actions for performance, initial state support for flexibility
 */

import React, { createContext, useContext, useState, useCallback, ReactNode } from 'react';

/**
 * {{CONTEXT_NAME}} state interface
 */
interface {{CONTEXT_NAME}}State {
  {{STATE_FIELD}}: {{STATE_TYPE}};
  {{STATE_FIELD_2}}: {{STATE_TYPE_2}};
}

/**
 * {{CONTEXT_NAME}} context type
 */
interface {{CONTEXT_NAME}}ContextType extends {{CONTEXT_NAME}}State {
  {{ACTION_NAME}}: ({{ACTION_PARAM}}: {{ACTION_PARAM_TYPE}}) => void;
  {{ACTION_NAME_2}}: () => void;
}

// Create context
const {{CONTEXT_NAME}}Context = createContext<{{CONTEXT_NAME}}ContextType | undefined>(
  undefined
);

/**
 * {{CONTEXT_NAME}} Provider Props
 */
interface {{CONTEXT_NAME}}ProviderProps {
  children: ReactNode;
  initialState?: Partial<{{CONTEXT_NAME}}State>;
}

/**
 * {{CONTEXT_NAME}} Provider Component
 *
 * {{CONTEXT_DESCRIPTION}}
 *
 * @example
 * ```tsx
 * <{{CONTEXT_NAME}}Provider>
 *   <App />
 * </{{CONTEXT_NAME}}Provider>
 * ```
 */
export const {{CONTEXT_NAME}}Provider: React.FC<{{CONTEXT_NAME}}ProviderProps> = ({
  children,
  initialState = {},
}) => {
  const [state, setState] = useState<{{CONTEXT_NAME}}State>({
    {{STATE_FIELD}}: {{DEFAULT_VALUE}},
    {{STATE_FIELD_2}}: {{DEFAULT_VALUE_2}},
    ...initialState,
  });

  // Actions
  const {{ACTION_NAME}} = useCallback(({{ACTION_PARAM}}: {{ACTION_PARAM_TYPE}}) => {
    setState(prev => ({
      ...prev,
      {{STATE_FIELD}}: {{ACTION_LOGIC}},
    }));
  }, []);

  const {{ACTION_NAME_2}} = useCallback(() => {
    setState({
      {{STATE_FIELD}}: {{DEFAULT_VALUE}},
      {{STATE_FIELD_2}}: {{DEFAULT_VALUE_2}},
    });
  }, []);

  const value: {{CONTEXT_NAME}}ContextType = {
    ...state,
    {{ACTION_NAME}},
    {{ACTION_NAME_2}},
  };

  return (
    <{{CONTEXT_NAME}}Context.Provider value={value}>
      {children}
    </{{CONTEXT_NAME}}Context.Provider>
  );
};

/**
 * Hook to use {{CONTEXT_NAME}} context
 *
 * @throws Error if used outside {{CONTEXT_NAME}}Provider
 */
export const use{{CONTEXT_NAME}} = (): {{CONTEXT_NAME}}ContextType => {
  const context = useContext({{CONTEXT_NAME}}Context);

  if (!context) {
    throw new Error(
      'use{{CONTEXT_NAME}} must be used within a {{CONTEXT_NAME}}Provider'
    );
  }

  return context;
};

