/**
 * Purpose: Template for Zustand store - lightweight state management with Zustand
 *
 * Scope: Application or feature-level state management with Zustand
 *
 * Overview: Generates a Zustand store with state definition, actions, async operations,
 *     middleware integration, and optional persistence. Provides simplified state management
 *     alternative to Redux with minimal boilerplate and direct state updates. Includes
 *     TypeScript interface for store shape combining state and actions, synchronous actions
 *     for immediate state updates, async actions with loading and error handling, reset
 *     function to clear state, devtools middleware for Redux DevTools integration, and
 *     persist middleware for localStorage/sessionStorage persistence with selective field
 *     configuration. The generated store follows Zustand patterns with immutable state
 *     updates through set function, get function for accessing state within actions,
 *     comprehensive error handling for async operations, and optional selector functions
 *     for optimized component subscriptions. Suitable for managing application state,
 *     user preferences, UI state, data caching, and any state that needs to be shared
 *     across components without Redux complexity.
 *
 * Dependencies: Zustand, zustand/middleware for devtools and persistence
 *
 * Exports: Custom hook for store access (use[StoreName]Store), optional selector functions
 *
 * Placeholders:
 *     - {{STORE_PURPOSE}}: Store purpose (e.g., "User authentication state")
 *     - {{STORE_SCOPE}}: Store scope (e.g., "Global auth state")
 *     - {{STORE_NAME}}: Store name in PascalCase (e.g., "Auth", "User", "Theme")
 *     - {{STORE_NAME_LOWER}}: Store name in camelCase (e.g., "auth", "user", "theme")
 *     - {{STORE_DESCRIPTION}}: Detailed store description
 *     - {{STATE_FIELD}}: First state field name (e.g., "user", "theme", "data")
 *     - {{STATE_TYPE}}: First state field type (e.g., "User | null", "ThemeMode", "Product[]")
 *     - {{STATE_FIELD_2}}: Second state field name (e.g., "preferences", "settings")
 *     - {{STATE_TYPE_2}}: Second state field type (e.g., "UserPreferences", "AppSettings")
 *     - {{INITIAL_VALUE}}: Initial value for first field (e.g., "null", "'light'", "[]")
 *     - {{INITIAL_VALUE_2}}: Initial value for second field (e.g., "{}", "defaultSettings")
 *     - {{ACTION_NAME}}: Synchronous action name (e.g., "setUser", "setTheme", "addItem")
 *     - {{ACTION_PARAM}}: Action parameter name (e.g., "user", "theme", "item")
 *     - {{ACTION_PARAM_TYPE}}: Action parameter type (e.g., "User", "ThemeMode", "Product")
 *     - {{ACTION_LOGIC}}: Action implementation logic (e.g., "action.payload", "newValue")
 *     - {{ASYNC_ACTION_NAME}}: Async action name (e.g., "fetchUser", "login", "loadData")
 *     - {{ASYNC_PARAM}}: Async parameter name (e.g., "userId", "credentials")
 *     - {{ASYNC_PARAM_TYPE}}: Async parameter type (e.g., "string", "LoginRequest")
 *     - {{ASYNC_LOGIC}}: Description of async operation
 *     - {{API_CALL}}: Actual API call implementation (e.g., "api.users.fetch(userId)")
 *
 * Usage: Copy template to stores directory, replace all {{PLACEHOLDERS}}, implement actions and async operations, use hook in components
 *
 * Related: react-component-with-hooks.tsx.template for consuming store, react-context.tsx.template for alternative state management
 *
 * Implementation: Zustand with TypeScript, devtools middleware for debugging, persist middleware for storage, loading and error states for async, selector functions for performance
 */

import { create } from 'zustand';
import { devtools, persist } from 'zustand/middleware';

/**
 * {{STORE_NAME}} state interface
 */
interface {{STORE_NAME}}Store {
  // State
  {{STATE_FIELD}}: {{STATE_TYPE}};
  {{STATE_FIELD_2}}: {{STATE_TYPE_2}};
  isLoading: boolean;
  error: Error | null;

  // Actions
  {{ACTION_NAME}}: ({{ACTION_PARAM}}: {{ACTION_PARAM_TYPE}}) => void;
  {{ASYNC_ACTION_NAME}}: ({{ASYNC_PARAM}}: {{ASYNC_PARAM_TYPE}}) => Promise<void>;
  reset: () => void;
}

/**
 * {{STORE_NAME}} Zustand store
 *
 * {{STORE_DESCRIPTION}}
 *
 * @example
 * ```tsx
 * const { {{STATE_FIELD}}, {{ACTION_NAME}} } = use{{STORE_NAME}}Store();
 * ```
 */
export const use{{STORE_NAME}}Store = create<{{STORE_NAME}}Store>()(
  devtools(
    persist(
      (set, get) => ({
        // Initial state
        {{STATE_FIELD}}: {{INITIAL_VALUE}},
        {{STATE_FIELD_2}}: {{INITIAL_VALUE_2}},
        isLoading: false,
        error: null,

        // Synchronous actions
        {{ACTION_NAME}}: ({{ACTION_PARAM}}) => {
          set({ {{STATE_FIELD}}: {{ACTION_LOGIC}} });
        },

        // Async actions
        {{ASYNC_ACTION_NAME}}: async ({{ASYNC_PARAM}}) => {
          set({ isLoading: true, error: null });

          try {
            // {{ASYNC_LOGIC}}
            const result = await {{API_CALL}};
            set({
              {{STATE_FIELD}}: result,
              isLoading: false,
            });
          } catch (error) {
            set({
              isLoading: false,
              error: error instanceof Error ? error : new Error('Unknown error'),
            });
          }
        },

        // Reset action
        reset: () => {
          set({
            {{STATE_FIELD}}: {{INITIAL_VALUE}},
            {{STATE_FIELD_2}}: {{INITIAL_VALUE_2}},
            isLoading: false,
            error: null,
          });
        },
      }),
      {
        name: '{{STORE_NAME_LOWER}}-storage',
        // Optionally persist only certain fields
        partialize: (state) => ({
          {{STATE_FIELD}}: state.{{STATE_FIELD}},
          // Don't persist loading/error states
        }),
      }
    ),
    { name: '{{STORE_NAME}}Store' }
  )
);

// Selectors (optional, for convenience)
export const select{{STATE_FIELD}} = (state: {{STORE_NAME}}Store) => state.{{STATE_FIELD}};
export const selectIsLoading = (state: {{STORE_NAME}}Store) => state.isLoading;
export const selectError = (state: {{STORE_NAME}}Store) => state.error;

