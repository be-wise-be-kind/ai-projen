/**
 * Purpose: Template for Vitest component test - comprehensive React component testing
 *
 * Scope: Unit and integration testing for React components with Testing Library
 *
 * Overview: Generates a comprehensive Vitest test suite for React components using React
 *     Testing Library. Provides organized test structure covering rendering, user interactions,
 *     conditional rendering, async behavior, and accessibility. Includes test setup with
 *     beforeEach hooks, mock data and props, rendering tests for different prop combinations,
 *     user interaction tests with userEvent API, conditional rendering tests for loading/error
 *     states, async behavior tests with waitFor utilities, and accessibility tests for ARIA
 *     attributes and keyboard navigation. The generated test suite follows testing best practices
 *     with descriptive test organization, user-centric queries, proper async handling, and
 *     accessibility validation. Demonstrates patterns for testing event handlers, form inputs,
 *     loading states, error handling, and keyboard accessibility. Suitable for testing UI
 *     components, forms, interactive elements, and any React component requiring comprehensive
 *     test coverage.
 *
 * Dependencies: Vitest, React Testing Library (@testing-library/react), @testing-library/user-event
 *
 * Exports: Test suite with organized test blocks for component behavior validation
 *
 * Placeholders:
 *     - {{TEST_PURPOSE}}: Test purpose (e.g., "Test UserCard component")
 *     - {{TEST_SCOPE}}: Test scope (e.g., "UserCard component behavior")
 *     - {{COMPONENT_NAME}}: Component name being tested (e.g., "UserCard", "LoginForm")
 *     - {{PROP_NAME}}: First prop name (e.g., "userId", "onSubmit")
 *     - {{PROP_VALUE}}: First prop mock value (e.g., "'123'", "mockHandler")
 *     - {{PROP_NAME_2}}: Second prop name (e.g., "title")
 *     - {{PROP_VALUE_2}}: Second prop mock value (e.g., "'Test Title'")
 *     - {{EXPECTED_TEXT}}: Expected text to find in rendered output (e.g., "'Welcome'")
 *     - {{OPTIONAL_PROP}}: Optional prop name (e.g., "className")
 *     - {{OPTIONAL_VALUE}}: Optional prop value (e.g., "'custom-class'")
 *     - {{ROLE}}: ARIA role for query (e.g., "button", "textbox", "heading")
 *     - {{BUTTON_NAME}}: Button accessible name (e.g., "Submit", "Cancel")
 *     - {{LABEL_TEXT}}: Input label text (e.g., "Email", "Password")
 *     - {{CONDITION_PROP}}: Conditional prop name (e.g., "showDetails")
 *     - {{ARIA_LABEL}}: ARIA label value (e.g., "'Close dialog'")
 *
 * Usage: Copy template to component test directory, replace all {{PLACEHOLDERS}}, implement component-specific test cases, run with 'npm test'
 *
 * Related: react-component.tsx.template for components under test, vitest-hook-test.tsx.template for hook testing
 *
 * Implementation: Vitest test framework, React Testing Library for rendering, userEvent for interactions, waitFor for async, accessibility-focused queries
 */

import { describe, it, expect, vi, beforeEach } from 'vitest';
import { render, screen, fireEvent, waitFor } from '@testing-library/react';
import userEvent from '@testing-library/user-event';
import { {{COMPONENT_NAME}} } from './{{COMPONENT_NAME}}';

describe('{{COMPONENT_NAME}}', () => {
  // Test data
  const mockProps = {
    {{PROP_NAME}}: {{PROP_VALUE}},
    {{PROP_NAME_2}}: {{PROP_VALUE_2}},
  };

  // Setup before each test
  beforeEach(() => {
    // Reset mocks, clear localStorage, etc.
  });

  describe('Rendering', () => {
    it('renders correctly with required props', () => {
      render(<{{COMPONENT_NAME}} {...mockProps} />);

      expect(screen.getByText({{EXPECTED_TEXT}})).toBeInTheDocument();
    });

    it('renders with all props', () => {
      render(
        <{{COMPONENT_NAME}}
          {...mockProps}
          {{OPTIONAL_PROP}}={{OPTIONAL_VALUE}}
        />
      );

      expect(screen.getByRole('{{ROLE}}')).toBeInTheDocument();
    });

    it('renders children when provided', () => {
      render(
        <{{COMPONENT_NAME}} {...mockProps}>
          <div>Child content</div>
        </{{COMPONENT_NAME}}>
      );

      expect(screen.getByText('Child content')).toBeInTheDocument();
    });
  });

  describe('User Interactions', () => {
    it('handles click events', async () => {
      const user = userEvent.setup();
      const handleClick = vi.fn();

      render(<{{COMPONENT_NAME}} {...mockProps} onClick={handleClick} />);

      const button = screen.getByRole('button', { name: /{{BUTTON_NAME}}/i });
      await user.click(button);

      expect(handleClick).toHaveBeenCalledTimes(1);
    });

    it('handles input changes', async () => {
      const user = userEvent.setup();
      const handleChange = vi.fn();

      render(<{{COMPONENT_NAME}} {...mockProps} onChange={handleChange} />);

      const input = screen.getByLabelText(/{{LABEL_TEXT}}/i);
      await user.type(input, 'test input');

      expect(input).toHaveValue('test input');
      expect(handleChange).toHaveBeenCalled();
    });
  });

  describe('Conditional Rendering', () => {
    it('shows loading state', () => {
      render(<{{COMPONENT_NAME}} {...mockProps} isLoading={true} />);

      expect(screen.getByText(/loading/i)).toBeInTheDocument();
    });

    it('shows error state', () => {
      const error = new Error('Test error');
      render(<{{COMPONENT_NAME}} {...mockProps} error={error} />);

      expect(screen.getByText(/test error/i)).toBeInTheDocument();
    });

    it('hides element when condition is false', () => {
      render(<{{COMPONENT_NAME}} {...mockProps} {{CONDITION_PROP}}={false} />);

      expect(screen.queryByRole('{{ROLE}}')).not.toBeInTheDocument();
    });
  });

  describe('Async Behavior', () => {
    it('loads and displays async data', async () => {
      render(<{{COMPONENT_NAME}} {...mockProps} />);

      // Wait for loading to finish
      await waitFor(() => {
        expect(screen.queryByText(/loading/i)).not.toBeInTheDocument();
      });

      // Check data is displayed
      expect(screen.getByText({{EXPECTED_TEXT}})).toBeInTheDocument();
    });
  });

  describe('Accessibility', () => {
    it('has proper ARIA attributes', () => {
      render(<{{COMPONENT_NAME}} {...mockProps} />);

      const element = screen.getByRole('{{ROLE}}');
      expect(element).toHaveAttribute('aria-label', {{ARIA_LABEL}});
    });

    it('is keyboard accessible', async () => {
      const user = userEvent.setup();
      const handleAction = vi.fn();

      render(<{{COMPONENT_NAME}} {...mockProps} onAction={handleAction} />);

      const element = screen.getByRole('{{ROLE}}');
      element.focus();
      await user.keyboard('{Enter}');

      expect(handleAction).toHaveBeenCalled();
    });
  });
});

