"""
Purpose: Main CLI entrypoint with Typer framework for command-line interface

Scope: CLI command definitions, option parsing, and command execution coordination

Overview: Provides the main CLI application using Typer with type hints for command definition,
    automatic option parsing, and Rich integration for styled output. Includes example commands
    (hello, config management) that demonstrate best practices for CLI design including error
    handling, logging configuration, state management, and user-friendly output with Rich
    styling. Serves as the entry point for the installed CLI tool and coordinates between
    user input and application logic.

Dependencies: typer for CLI framework, rich for styled output, logging for structured output

Exports: app (main Typer application), hello command, config command group

Interfaces: Typer CLI commands, configuration state via State class, logging integration

Implementation: Typer decorators with Annotated type hints, Rich console output, state management
"""

import typer
import logging
import sys
from pathlib import Path
from typing import Optional, Annotated, Any
from enum import Enum

from rich import print as rprint
from rich.console import Console
from rich.table import Table

from src.config import load_config, save_config, validate_config, ConfigError
from src import __version__

# Configure module logger
logger = logging.getLogger(__name__)

# Rich console for styled output
console = Console()


class State:
    """Application state shared across commands (replaces Click's ctx.obj)."""

    def __init__(self) -> None:
        self.config: dict[str, Any] = {}
        self.config_path: Optional[Path] = None
        self.verbose: bool = False


# Global state instance
state = State()


class OutputFormat(str, Enum):
    """Output format choices for config display."""

    text = "text"
    json = "json"
    yaml = "yaml"


def setup_logging(verbose: bool = False) -> None:
    """
    Configure logging for the CLI application.

    Args:
        verbose: Enable DEBUG level logging if True, INFO otherwise.
    """
    level = logging.DEBUG if verbose else logging.INFO

    logging.basicConfig(
        level=level,
        format='%(asctime)s | %(levelname)-8s | %(message)s',
        datefmt='%Y-%m-%d %H:%M:%S',
        stream=sys.stdout
    )


def version_callback(value: bool) -> None:
    """Show version and exit."""
    if value:
        rprint(f"[cyan]{{PROJECT_NAME}}[/cyan] version [green]{__version__}[/green]")
        raise typer.Exit()


# Create main app
app = typer.Typer(
    name="{{PROJECT_NAME}}",
    help="{{PROJECT_DESCRIPTION}} - A professional command-line tool built with Python and Typer.",
    add_completion=True,
    rich_markup_mode="rich",
)

# Create config subcommand group
config_app = typer.Typer(
    help="Configuration management commands.",
    rich_markup_mode="rich",
)
app.add_typer(config_app, name="config")


@app.callback()
def main(
    verbose: Annotated[bool, typer.Option(
        "--verbose", "-v",
        help="Enable verbose output"
    )] = False,
    config: Annotated[Optional[Path], typer.Option(
        "--config", "-c",
        help="Path to config file",
    )] = None,
    version: Annotated[bool, typer.Option(
        "--version",
        help="Show version and exit",
        callback=version_callback,
        is_eager=True,
    )] = False,
) -> None:
    """
    [bold cyan]{{PROJECT_NAME}}[/bold cyan] - {{PROJECT_DESCRIPTION}}

    A professional command-line tool built with Python and Typer.

    [bold]Examples:[/bold]

        [dim]# Show help[/dim]
        {{PROJECT_NAME}} --help

        [dim]# Run with verbose output[/dim]
        {{PROJECT_NAME}} --verbose hello --name World

        [dim]# Use custom config[/dim]
        {{PROJECT_NAME}} --config myconfig.yaml config show
    """
    # Setup logging
    setup_logging(verbose)

    # Load configuration
    try:
        if config:
            state.config = load_config(config)
            state.config_path = config
        else:
            state.config = load_config()
            state.config_path = None

        logger.debug("Configuration loaded successfully")
    except ConfigError as e:
        rprint(f"[red]Error loading configuration: {e}[/red]")
        raise typer.Exit(code=2)

    state.verbose = verbose


@app.command()
def hello(
    name: Annotated[str, typer.Option(
        "--name", "-n",
        help="Name to greet"
    )] = "World",
    uppercase: Annotated[bool, typer.Option(
        "--uppercase", "-u",
        help="Convert greeting to uppercase"
    )] = False,
) -> None:
    """
    Print a greeting message.

    This is a simple example command demonstrating CLI basics.

    [bold]Examples:[/bold]

        [dim]# Basic greeting[/dim]
        {{PROJECT_NAME}} hello

        [dim]# Custom name[/dim]
        {{PROJECT_NAME}} hello --name Alice

        [dim]# Uppercase output[/dim]
        {{PROJECT_NAME}} hello --name Bob --uppercase
    """
    greeting_template = state.config.get('greeting', 'Hello')
    message = f"{greeting_template}, {name}!"

    if uppercase:
        message = message.upper()

    # Use Rich for styled output
    rprint(f"[green]{message}[/green]")

    if state.verbose:
        logger.info(f"Greeted {name} with template '{greeting_template}'")


@config_app.command("show")
def config_show(
    format: Annotated[OutputFormat, typer.Option(
        "--format", "-f",
        help="Output format"
    )] = OutputFormat.text,
) -> None:
    """
    Display current configuration.

    Shows all configuration values in the specified format.

    [bold]Examples:[/bold]

        [dim]# Show as text table[/dim]
        {{PROJECT_NAME}} config show

        [dim]# Show as JSON[/dim]
        {{PROJECT_NAME}} config show --format json

        [dim]# Show as YAML[/dim]
        {{PROJECT_NAME}} config show --format yaml
    """
    cfg = state.config

    if format == OutputFormat.json:
        import json
        rprint(json.dumps(cfg, indent=2))
    elif format == OutputFormat.yaml:
        import yaml
        rprint(yaml.dump(cfg, default_flow_style=False, sort_keys=False))
    else:
        # Rich table for text format
        table = Table(title="Current Configuration", show_header=True, header_style="bold cyan")
        table.add_column("Key", style="cyan", width=20)
        table.add_column("Value", style="green")
        for key, value in cfg.items():
            table.add_row(str(key), str(value))
        console.print(table)


@config_app.command("get")
def config_get(
    key: Annotated[str, typer.Argument(help="Configuration key to retrieve")],
) -> None:
    """
    Get specific configuration value.

    [bold]Examples:[/bold]

        [dim]# Get log level[/dim]
        {{PROJECT_NAME}} config get log_level

        [dim]# Get greeting template[/dim]
        {{PROJECT_NAME}} config get greeting
    """
    cfg = state.config

    if key not in cfg:
        rprint(f"[red]Configuration key not found: {key}[/red]")
        raise typer.Exit(code=1)

    rprint(cfg[key])


@config_app.command("set")
def config_set(
    key: Annotated[str, typer.Argument(help="Configuration key to set")],
    value: Annotated[str, typer.Argument(help="New value for the key")],
) -> None:
    """
    Set configuration value.

    [bold]Examples:[/bold]

        [dim]# Set log level[/dim]
        {{PROJECT_NAME}} config set log_level DEBUG

        [dim]# Set greeting template[/dim]
        {{PROJECT_NAME}} config set greeting "Hi"

        [dim]# Set numeric value[/dim]
        {{PROJECT_NAME}} config set max_retries 5
    """
    cfg = state.config

    # Type conversion for common types
    converted_value: Any = value
    if value.lower() in ['true', 'false']:
        converted_value = value.lower() == 'true'
    elif value.isdigit():
        converted_value = int(value)
    elif value.replace('.', '', 1).isdigit() and value.count('.') == 1:
        converted_value = float(value)

    # Update config
    cfg[key] = converted_value

    # Validate updated config
    try:
        is_valid, errors = validate_config(cfg)
        if not is_valid:
            rprint("[red]Invalid configuration:[/red]")
            for error in errors:
                rprint(f"  [red]• {error}[/red]")
            raise typer.Exit(code=1)
    except Exception as e:
        rprint(f"[red]Validation error: {e}[/red]")
        raise typer.Exit(code=1)

    # Save config
    try:
        save_config(cfg, state.config_path)
        rprint(f"[green]✓ Set {key} = {converted_value}[/green]")

        if state.verbose:
            logger.info(f"Configuration updated: {key}={converted_value}")
    except ConfigError as e:
        rprint(f"[red]Error saving configuration: {e}[/red]")
        raise typer.Exit(code=1)


@config_app.command("reset")
def config_reset(
    yes: Annotated[bool, typer.Option(
        "--yes", "-y",
        help="Skip confirmation prompt"
    )] = False,
) -> None:
    """
    Reset configuration to defaults.

    [bold]Examples:[/bold]

        [dim]# Reset with confirmation[/dim]
        {{PROJECT_NAME}} config reset

        [dim]# Reset without confirmation[/dim]
        {{PROJECT_NAME}} config reset --yes
    """
    if not yes:
        confirm = typer.confirm("Reset configuration to defaults?")
        if not confirm:
            raise typer.Abort()

    from src.config import DEFAULT_CONFIG

    try:
        save_config(DEFAULT_CONFIG.copy(), state.config_path)
        rprint("[green]✓ Configuration reset to defaults[/green]")

        if state.verbose:
            logger.info("Configuration reset to defaults")
    except ConfigError as e:
        rprint(f"[red]Error resetting configuration: {e}[/red]")
        raise typer.Exit(code=1)


if __name__ == "__main__":
    app()
