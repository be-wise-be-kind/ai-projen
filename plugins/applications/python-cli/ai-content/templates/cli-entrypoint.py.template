"""
Purpose: Template for creating new CLI modules with Typer framework

Scope: CLI entrypoint with command structure, options, and error handling

Overview: This template provides a starting point for creating CLI modules with Typer and type hints.
    Includes command group setup, common options, state management, logging configuration,
    and error handling patterns. Follow this structure for consistent CLI development with
    proper help text, type validation, Rich output, and testing support.

Placeholders:
  {{MODULE_NAME}}: Python module name in snake_case
    - Type: string (valid Python identifier)
    - Example: "data_processor" or "api_client"
    - Required: yes

  {{MODULE_DESCRIPTION}}: Brief description of module functionality
    - Type: string
    - Example: "Data processing commands for ETL operations"
    - Required: yes

  {{COMMAND_NAME}}: Name of the CLI command
    - Type: string (lowercase with hyphens)
    - Example: "process-data" or "fetch-api"
    - Required: yes

  {{COMMAND_DESCRIPTION}}: Description of what the command does
    - Type: string
    - Example: "Process input data and generate output"
    - Required: yes

Usage:
  1. Copy template:
     cp .ai/templates/python-cli/cli-entrypoint.py.template src/{{MODULE_NAME}}.py

  2. Replace placeholders:
     - {{MODULE_NAME}}: Replace with your module name
     - {{MODULE_DESCRIPTION}}: Replace with module description
     - {{COMMAND_NAME}}: Replace with command name
     - {{COMMAND_DESCRIPTION}}: Replace with command description

  3. Remove this template header (lines 1-40)

  4. Customize commands and options as needed

  5. Validate:
     python -m src.{{MODULE_NAME}} --help

Related: .ai/howtos/python-cli/how-to-add-cli-command.md, .ai/docs/python-cli-architecture.md
"""

"""
Purpose: {{MODULE_DESCRIPTION}}

Scope: CLI commands for {{MODULE_NAME}} functionality

Overview: This module provides CLI commands for {{MODULE_NAME}} using Typer framework.
    Includes command definitions, option parsing with type hints, error handling, and
    integration with configuration and logging systems. Commands are organized into groups
    for better organization and support comprehensive help text with Rich styling.

Dependencies: typer for CLI framework, rich for styled output, logging for output

Exports: {{MODULE_NAME}}_app command group, individual commands

Interfaces: Typer CLI commands, configuration state, logging integration
"""

import typer
import logging
from pathlib import Path
from typing import Optional, Annotated, Any
from enum import Enum

from rich import print as rprint
from rich.console import Console

# Configure logging
logger = logging.getLogger(__name__)
console = Console()


class State:
    """Application state shared across commands."""

    def __init__(self) -> None:
        self.config_path: Optional[Path] = None
        self.verbose: bool = False


state = State()


class OutputFormat(str, Enum):
    """Output format choices."""

    json = "json"
    yaml = "yaml"
    text = "text"


# Create main app for this module
{{MODULE_NAME}}_app = typer.Typer(
    help="{{MODULE_DESCRIPTION}}",
    rich_markup_mode="rich",
)


@{{MODULE_NAME}}_app.callback()
def main(
    verbose: Annotated[bool, typer.Option(
        "--verbose", "-v",
        help="Enable verbose output"
    )] = False,
    config: Annotated[Optional[Path], typer.Option(
        "--config", "-c",
        help="Config file path",
        exists=True,
    )] = None,
) -> None:
    """
    [bold cyan]{{MODULE_DESCRIPTION}}[/bold cyan]

    This command group provides {{MODULE_NAME}} functionality with comprehensive
    configuration and logging support.
    """
    # Configure logging level
    level = logging.DEBUG if verbose else logging.INFO
    logging.basicConfig(
        level=level,
        format='%(asctime)s | %(levelname)-8s | %(message)s',
        datefmt='%Y-%m-%d %H:%M:%S'
    )

    # Load configuration if provided
    if config:
        state.config_path = config
        logger.debug(f"Using config file: {config}")

    state.verbose = verbose


@{{MODULE_NAME}}_app.command("{{COMMAND_NAME}}")
def {{COMMAND_NAME}}_command(
    input_file: Annotated[Path, typer.Argument(
        help="Path to input file to process",
        exists=True,
    )],
    output_file: Annotated[Path, typer.Argument(
        help="Path where output will be written",
    )],
    format: Annotated[OutputFormat, typer.Option(
        "--format", "-f",
        help="Output format"
    )] = OutputFormat.text,
    overwrite: Annotated[bool, typer.Option(
        "--overwrite",
        help="Overwrite output file if exists"
    )] = False,
) -> None:
    """
    {{COMMAND_DESCRIPTION}}

    [bold]Examples:[/bold]

        [dim]# Basic usage[/dim]
        cli {{COMMAND_NAME}} input.txt output.txt

        [dim]# With JSON format[/dim]
        cli {{COMMAND_NAME}} input.txt output.json --format json

        [dim]# Overwrite existing output[/dim]
        cli {{COMMAND_NAME}} input.txt output.txt --overwrite
    """
    try:
        # Validate inputs
        if output_file.exists() and not overwrite:
            rprint(f"[red]Output file already exists: {output_file}. Use --overwrite to replace.[/red]")
            raise typer.Exit(code=1)

        if state.verbose:
            logger.info(f"Processing {input_file} -> {output_file}")
            logger.info(f"Output format: {format.value}")

        # TODO: Implement command logic here
        # Example:
        # 1. Read input file
        # 2. Process data
        # 3. Write output file

        with open(input_file, 'r') as infile:
            content = infile.read()

        # Process content based on format
        if format == OutputFormat.json:
            # Convert to JSON
            processed = content  # TODO: Actual conversion
        elif format == OutputFormat.yaml:
            # Convert to YAML
            processed = content  # TODO: Actual conversion
        else:
            # Keep as text
            processed = content

        # Write output
        with open(output_file, 'w') as outfile:
            outfile.write(processed)

        rprint(f"[green]✓ Successfully processed {input_file} to {output_file}[/green]")

        if state.verbose:
            logger.info("Processing complete")

    except FileNotFoundError as e:
        rprint(f"[red]File not found: {e.filename}[/red]")
        raise typer.Exit(code=1)
    except PermissionError as e:
        rprint(f"[red]Permission denied: {e.filename}[/red]")
        raise typer.Exit(code=1)
    except Exception as e:
        logger.exception("Unexpected error occurred")
        rprint(f"[red]Processing failed: {str(e)}[/red]")
        raise typer.Exit(code=1)


@{{MODULE_NAME}}_app.command("validate")
def validate_command(
    file_path: Annotated[Path, typer.Argument(
        help="Path to file to validate",
        exists=True,
    )],
) -> None:
    """
    Validate input file format and content.
    """
    try:
        if state.verbose:
            logger.info(f"Validating {file_path}")

        # TODO: Implement validation logic
        is_valid = True
        errors: list[str] = []

        if is_valid:
            rprint(f"[green]✓ {file_path} is valid[/green]")
        else:
            rprint(f"[red]✗ {file_path} is invalid[/red]")
            for error in errors:
                rprint(f"  [red]• {error}[/red]")
            raise typer.Abort()

    except Exception as e:
        logger.exception("Validation failed")
        rprint(f"[red]Validation error: {str(e)}[/red]")
        raise typer.Exit(code=1)


@{{MODULE_NAME}}_app.command("info")
def info_command() -> None:
    """Display module information and configuration."""
    rprint(f"[bold cyan]Module:[/bold cyan] {{MODULE_NAME}}")
    rprint(f"[bold cyan]Description:[/bold cyan] {{MODULE_DESCRIPTION}}")

    if state.config_path:
        rprint(f"[bold cyan]Config:[/bold cyan] {state.config_path}")

    if state.verbose:
        rprint("[bold cyan]Verbose:[/bold cyan] enabled")


if __name__ == "__main__":
    {{MODULE_NAME}}_app()
